[1mdiff --git a/build.zig.zon b/build.zig.zon[m
[1mindex 83a6b17..f374a99 100644[m
[1m--- a/build.zig.zon[m
[1m+++ b/build.zig.zon[m
[36m@@ -6,7 +6,7 @@[m
     .dependencies = .{[m
         .lmap = .{[m
             .url = "/home/foo/lmap/",[m
[31m-            .hash = "lmap-0.0.0-UG7HYNMPAABwbeYolUiAfiWBQsX0_5jEV6gjrCPZ8vUe",[m
[32m+[m[32m            .hash = "lmap-0.0.0-UG7HYP0OAAAIOK7SKSd6IxEAKQvst9SOmJJPyieFfSy2",[m
         },[m
     },[m
 [m
[1mdiff --git a/src/injector.zig b/src/injector.zig[m
[1mindex a6a590e..527d616 100644[m
[1m--- a/src/injector.zig[m
[1m+++ b/src/injector.zig[m
[36m@@ -61,8 +61,24 @@[m [mpub inline fn inject(allocator: std.mem.Allocator, zygote_pid: std.posix.pid_t)[m
         _ = try remote_mem.read(regs.pc, &initial_mem);[m
         std.log.debug("[*] 32 bytes at pc {x} = {x}", .{ regs.pc, std.fmt.fmtSliceHexLower(&initial_mem) });[m
 [m
[32m+[m[32m        var parser = try ProcessMapParser.init(allocator, child_pid);[m
[32m+[m[32m        defer parser.deinit();[m
[32m+[m
[32m+[m[32m        const libc_map_rx = blk: {[m
[32m+[m[32m            for (parser.maps.items) |map| {[m
[32m+[m[32m                if (std.mem.endsWith(u8, map.path, "libc.so") and map.perms.execute) {[m
[32m+[m[32m                    break :blk map;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            return error.LibcNotFound;[m
[32m+[m[32m        };[m
[32m+[m
         // 14. write jmp[m
[31m-        const code_cave_addr = try remote_mem.getCodeCave(regs.pc, regs.pc + 256 * 256, Stubs.ARM64Trampoline.len);[m
[32m+[m[32m        const code_cave_addr = try remote_mem.getCodeCave([m
[32m+[m[32m            libc_map_rx.start,[m
[32m+[m[32m            libc_map_rx.start + 1024 * 1024,[m
[32m+[m[32m            Stubs.ARM64Trampoline.len,[m
[32m+[m[32m        );[m
         std.log.debug("[*] code cave: {x}\n", .{code_cave_addr});[m
 [m
         // 15. write jmp[m
[1mdiff --git a/src/remote/memory.zig b/src/remote/memory.zig[m
[1mindex 4efbade..538022d 100644[m
[1m--- a/src/remote/memory.zig[m
[1m+++ b/src/remote/memory.zig[m
[36m@@ -31,25 +31,12 @@[m [mpub const RemoteMemory = struct {[m
         defer self.allocator.free(buf);[m
 [m
         const read_len = try self.readIov(search_start_addr, buf);[m
[31m-        const match = try self.allocator.create([cave_size]u8);[m
[31m-        defer self.allocator.destroy(match);[m
 [m
[31m-        const offset = std.mem.indexOf(u8, buf[0..read_len], match) orelse return error.CaveNotFound;[m
[31m-        return search_start_addr + offset;[m
[31m-[m
[31m-        // var consecutive_zeros: usize = 0;[m
[31m-        // for (buf[0..read_len], 0..) |byte, i| {[m
[31m-        //     if (byte == 0x00) {[m
[31m-        //         consecutive_zeros += 1;[m
[31m-        //         if (consecutive_zeros >= cave_size) {[m
[31m-        //             return search_start_addr + i - (cave_size - 1);[m
[31m-        //         }[m
[31m-        //     } else {[m
[31m-        //         consecutive_zeros = 0;[m
[31m-        //     }[m
[31m-        // }[m
[32m+[m[32m        // Create a zero-filled pattern to search for[m
[32m+[m[32m        const pattern = [_]u8{0x00} ** cave_size;[m
 [m
[31m-        // return error.CaveNotFound;[m
[32m+[m[32m        const offset = std.mem.indexOf(u8, buf[0..read_len], &pattern) orelse return error.CaveNotFound;[m
[32m+[m[32m        return search_start_addr + offset;[m
     }[m
 [m
     pub inline fn read(self: @This(), addr: usize, buf: []u8) !usize {[m
