const std = @import("std");

// $ xxd -c1 -p stub.bin

pub const ARM64Trampoline = &[_]u8{
    0xc0, 0x00, 0x00, 0x10, //     adr x0, bin_ls
    0xe0, 0x7f, 0xbf, 0xa9, // stp x0, xzr, [sp, #-16]! // create and store custom argv on the stack
    0xe1, 0x03, 0x00, 0x91, // mov x1, sp
    0xe2, 0x03, 0x1f, 0xaa, // mov x2, xzr
    0xa8, 0x1b, 0x80, 0xd2, // mov x8, #221 // execve syscall number
    0x01, 0x00, 0x00, 0xd4, // svc #0
    0x2f, 0x62, 0x69, 0x6e, // Initialize /bin/ls\0
    0x2f, 0x6c, 0x73, 0x00, // as an ascii string
};

pub const ARM64Exit = &[_]u8{
    0x1f, 0x75, 0x08, 0xd5, // ic      iallu       // Invalidate all instruction cache to PoU
    0x9f, 0x37, 0x03, 0xd5, // dsb     nsh         // Ensure completion of invalidation
    0xdf, 0x3f, 0x03, 0xd5, // isb                 // Synchronize pipeline
    0x00, 0x00, 0x80, 0x92, // mov x0, #-1
    0xa8, 0x0b, 0x80, 0xd2, // mov x8, #93 // exit
    0x01, 0x00, 0x00, 0xd4, // svc #0
};

pub const ARM64CreateFile = &[_]u8{
    0xe0, 0x03, 0x1f, 0xaa,
    0x41, 0x01, 0x00, 0x10,
    0x02, 0x08, 0x80, 0xd2,
    0xc3, 0x36, 0x80, 0xd2,
    0x08, 0x07, 0x80, 0xd2,
    0x01, 0x00, 0x00, 0xd4,
    0x28, 0x07, 0x80, 0xd2,
    0x01, 0x00, 0x00, 0xd4,
    0x00, 0x00, 0x80, 0xd2,
    0xa8, 0x0b, 0x80, 0xd2,
    0x01, 0x00, 0x00, 0xd4,
    0x2f, 0x64, 0x61, 0x74,
    0x61, 0x2f, 0x6c, 0x6f,
    0x63, 0x61, 0x6c, 0x2f,
    0x74, 0x6d, 0x70, 0x2f,
    0x68, 0x65, 0x6c, 0x6c,
    0x6f, 0x2e, 0x74, 0x78,
    0x74, 0x00,
};

pub const ARM64Segfault = &[_]u8{
    0x00, 0x00, 0x80, 0xD2,
    0x21, 0x00, 0x80, 0xD2,
    0x00, 0x00, 0x40, 0xF9,
};

pub inline fn ARM64BranchToAddress(address: usize) []const u8 {
    var bytes: [@sizeOf(usize)]u8 = undefined;
    std.mem.writeInt(u64, &bytes, address, .little);

    return &[_]u8{
        0x40, 0x55, 0x95, 0xd2,
        0x60, 0x77, 0xb7, 0xf2,
        0x80, 0x19, 0xc0, 0xf2,
        0x00, 0x00, 0x1f, 0xd6,
    };
}

test "arm64 movk" {
    const address = 0x00CCBBBBAAAA;
    const part0 = @as(u16, @truncate(address));
    const part1 = @as(u16, @truncate(address >> 16));
    const part2 = @as(u16, @truncate(address >> 32));

    const mov_x0_part0 = 0xD2800000 | (@as(u32, part0) << 5);
    const movk_x0_part1 = 0xF2800000 | (@as(u32, part1) << 5) | (1 << 21);
    const movk_x0_part2 = 0xF2800000 | (@as(u32, part2) << 5) | (2 << 21);

    const br_x0 = 0xD61F0000; // BR x0

    // Pack into bytes (little-endian)
    var code: [16]u8 = undefined;
    std.mem.writeInt(u32, code[0..4], mov_x0_part0, .little);
    std.mem.writeInt(u32, code[4..8], movk_x0_part1, .little);
    std.mem.writeInt(u32, code[8..12], movk_x0_part2, .little);
    std.mem.writeInt(u32, code[12..16], br_x0, .little);

    std.debug.print("{x}\n", .{std.fmt.fmtSliceHexLower(&code)});
}
